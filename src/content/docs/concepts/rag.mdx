---
title: RAG
---

RAG (Retrieval Augmented Generation) enables agents to access, search, and reason over document content, providing more accurate and contextual responses.

## RAG Architecture

The RAG system in Astreus consists of:

- **Document Parsing**: Extracting text and metadata from documents
- **Chunking**: Breaking documents into manageable pieces (Vector RAG)
- **Embedding Generation**: Creating vector representations of text chunks
- **Vector Storage**: Storing embeddings for semantic search
- **Retrieval**: Finding relevant content based on semantic similarity
- **Context Augmentation**: Adding retrieved content to agent prompts

## RAG Types

Astreus supports two types of RAG systems:

### Vector RAG
- **Best for**: Large document collections, semantic search, chunked content
- **Features**: Document chunking, vector embeddings, similarity search
- **Tools**: Full CRUD operations (add, get, delete documents)

### Document RAG  
- **Best for**: Smaller document sets, metadata-based filtering, whole documents
- **Features**: Document storage, metadata search, content search
- **Tools**: Search and metadata filtering

## Setting Up RAG

### Vector RAG Setup

```typescript
import { 
  createRAG, 
  RAGType,
  parsePDF, 
  createProvider, 
  createDatabase 
} from '@astreus-ai/astreus';

(async () => {
  // Initialize components
  const db = await createDatabase();
  const provider = createProvider({ type: 'openai', model: 'gpt-4o-mini' });
  
  // Parse a PDF document
  const document = await parsePDF('path/to/document.pdf');
  
  // Create a Vector RAG system
  const rag = await createRAG({
    type: RAGType.VECTOR,
    database: db,
    tableName: "vector_embeddings",
    chunkSize: 1000,        // Size of text chunks
    chunkOverlap: 200       // Overlap between chunks
  });
  
  // Add documents to the RAG system
  await rag.addDocument({
    content: document.content,
    metadata: { source: 'manual', type: 'pdf' }
  });
})();
```

### Document RAG Setup

```typescript
import { 
  createRAG, 
  RAGType,
  createDatabase 
} from '@astreus-ai/astreus';

(async () => {
  // Initialize components
  const db = await createDatabase();
  
  // Create a Document RAG system
  const rag = await createRAG({
    type: RAGType.DOCUMENT,
    database: db,
    tableName: "documents",
    storeEmbeddings: true    // Enable semantic search
  });
  
  // Add documents to the RAG system
  await rag.addDocument({
    content: "Your document content here...",
    metadata: { category: 'support', priority: 'high' }
  });
})();
```

## RAG Configuration Options

| Option | Type | Description | Required | RAG Type |
|--------|------|-------------|----------|----------|
| `type` | RAGType | Vector or Document RAG | Yes | Both |
| `database` | Database | Database for storing data | Yes | Both |
| `tableName` | string | Table name for storage | No | Both |
| `maxResults` | number | Max results per query | No | Both |
| `chunkSize` | number | Size of document chunks | No | Vector |
| `chunkOverlap` | number | Overlap between chunks | No | Vector |
| `storeEmbeddings` | boolean | Enable embeddings | No | Document |

## Using RAG with Agents

Integrate RAG with an agent to automatically provide document search capabilities:

```typescript
import { 
  createAgent, 
  createProvider,
  createMemory,
  createDatabase,
  createRAG,
  RAGType,
  parsePDF
} from '@astreus-ai/astreus';

(async () => {
  // Initialize components
  const db = await createDatabase();
  const memory = await createMemory({ database: db, tableName: "memories" });
  const provider = createProvider({ type: 'openai', model: 'gpt-4o-mini' });
  
  // Parse documents and create RAG
  const document = await parsePDF('product_manual.pdf');
  const rag = await createRAG({
    type: RAGType.VECTOR,
    database: db,
    chunkSize: 1000,
    chunkOverlap: 200
  });
  
  // Add document to RAG
  await rag.addDocument({
    content: document.content,
    metadata: { source: 'product_manual', type: 'documentation' }
  });
  
  // Create agent with RAG - tools are automatically added!
  const agent = await createAgent({
    name: 'ProductAssistant',
    description: 'A product support assistant',
    provider: provider,
    memory: memory,
    database: db,
    rag: rag,  // RAG tools are automatically created
    systemPrompt: "You are a helpful product support assistant. Use the rag_search tool to find relevant information from the product documentation before answering questions."
  });
  
  // The agent now has access to RAG tools automatically!
  const response = await agent.chat("How do I reset my device to factory settings?");
  console.log(response);
})();
```

## Automatic RAG Tools

When you add a RAG instance to an agent, the following tools are automatically available:

### All RAG Types
- **`rag_search`**: Search through documents using semantic similarity

### Vector RAG Only
- **`rag_add_document`**: Add new documents to the RAG system
- **`rag_get_document`**: Retrieve a specific document by ID
- **`rag_delete_document`**: Delete a document from the system

### Document RAG Only  
- **`rag_search_by_metadata`**: Search documents by metadata properties

## Tool Usage Examples

The agent can now use these tools automatically:

```typescript
// The agent will automatically use rag_search when relevant
const response = await agent.chat("What does the manual say about troubleshooting?");

// For Vector RAG, the agent can also manage documents
const addResponse = await agent.chat("Add this new FAQ content to our knowledge base: 'Q: How to contact support? A: Email us at support@company.com'");

// For Document RAG, metadata search is available
const metadataResponse = await agent.chat("Find all high-priority support documents");
```

## Querying RAG Directly

You can also query the RAG system directly without an agent:

```typescript
// Search for relevant content
const results = await rag.search("How to configure network settings", 5);

// Results contain matching document chunks
results.forEach(result => {
  console.log(`Content: ${result.content}`);
  console.log(`Similarity: ${result.similarity}`);
  console.log(`Source: ${result.sourceId}`);
  console.log(`Metadata:`, result.metadata);
});
```

## Parsing Multiple Documents

You can parse multiple documents and directories:

```typescript
import { parsePDF, parseDirectoryOfPDFs } from '@astreus-ai/astreus';

// Parse a single PDF
const document1 = await parsePDF('path/to/document1.pdf');

// Parse a directory of PDFs
const documents = await parseDirectoryOfPDFs('path/to/document_directory');

// Add all documents to RAG
for (const doc of documents) {
  await rag.addDocument({
    content: doc.content,
    metadata: doc.metadata
  });
}
```

## Document Processing Options

When parsing documents, you can customize the processing:

```typescript
// Parse a PDF with custom options
const document = await parsePDF('document.pdf', {
  titleFromFilename: true,  // Use filename as document title
  extractImages: true,      // Extract and process images
  ocrEnabled: true,         // Use OCR for scanned documents
  language: "en",           // Specify document language
  metadata: {               // Add custom metadata
    author: "Jane Smith",
    department: "Engineering",
    confidentiality: "Internal"
  }
});
```

## Adding Custom Document Types

The RAG system supports custom document types:

```typescript
// Add a custom document directly
await rag.addDocument({
  content: "Full text content of the document...",
  metadata: {
    title: "API Documentation",
    source: "internal-wiki",
    lastUpdated: "2023-05-15",
    category: "technical"
  }
});
```

## Best Practices

### Choosing RAG Type
- Use **Vector RAG** for large documents that benefit from chunking
- Use **Document RAG** for smaller documents or when you need metadata filtering

### Chunk Configuration (Vector RAG)
- **Small chunks (500-800)**: Better for precise answers
- **Large chunks (1000-1500)**: Better for context understanding
- **Overlap (100-300)**: Ensures important information isn't lost at boundaries

### Metadata Strategy
- Add meaningful metadata for better filtering
- Include source, category, date, and other relevant fields
- Use consistent metadata schemas across documents 