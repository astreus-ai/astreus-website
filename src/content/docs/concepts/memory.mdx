---
title: Memory
---

Memory enables agents to store and recall conversation history, allowing for contextual understanding and continuity in interactions.

## Memory Architecture

Astreus Memory system consists of:

- **Conversation History**: Stores all messages exchanged with the agent
- **Embedding Storage**: Optional vector representations for semantic search
- **Session Management**: Organizes conversations into separate sessions
- **Metadata Support**: Allows attaching additional context to messages
- **Persistence Layer**: Saves history to a database for long-term storage

## Creating Memory

To create a memory instance, use the `createMemory` function:

```typescript
import { createMemory, createDatabase } from '@astreus-ai/astreus';

// Initialize the database first
const db = await createDatabase();

// Create a basic memory instance
const memory = await createMemory({
  database: db,
  tableName: "agent_memories",
  maxEntries: 50  // Limit the size of conversation history
});

// Create memory with embeddings enabled for semantic search
const vectorMemory = await createMemory({
  database: db,
  tableName: "vector_memories",
  maxEntries: 100,
  enableEmbeddings: true  // Enables semantic search capabilities
});
```

## Memory Configuration Options

| Option | Type | Description | Required |
|--------|------|-------------|----------|
| `database` | Database | Database instance for persistence | Yes |
| `tableName` | string | Name of the database table | Yes |
| `maxEntries` | number | Maximum number of messages to store per session | No (default: 100) |
| `enableEmbeddings` | boolean | Enable vector embeddings for semantic search | No (default: false) |
| `embeddingProvider` | Provider | Provider for generating embeddings | No (uses agent's provider if not specified) |
| `embeddingDimension` | number | Dimension of embedding vectors | No (provider default) |

## Storing and Retrieving Messages

Memory instances provide methods to add and retrieve messages:

```typescript
// Add a message to memory
await memory.add({
  role: "user",  // Can be 'user', 'assistant', 'system', etc.
  content: "What's the weather like in Paris?",
  sessionId: "session123",  // Optional, defaults to 'default'
  userId: "user456",        // Optional user identifier
  metadata: {               // Optional additional data
    timestamp: Date.now(),
    source: "web_interface"
  }
});

// Retrieve messages for a session
const sessionHistory = await memory.getBySession("session123");

// Get the most recent messages
const recentMessages = await memory.getBySession("session123", { limit: 10 });
```

## Semantic Search with Embeddings

If embeddings are enabled, you can search for semantically similar content:

```typescript
// Search for messages that are semantically similar to a query
const results = await memory.searchSimilar(
  "travel recommendations",  // Search query
  {
    sessionId: "session123",  // Optional: limit search to a specific session
    limit: 5,                 // Return top 5 most similar results
    threshold: 0.75           // Minimum similarity score (0-1)
  }
);

// Results contains messages most similar to the query
results.forEach(result => {
  console.log(`Score: ${result.score}, Content: ${result.entry.content}`);
});
```

## Managing Memory

You can manage memory through various utility methods:

```typescript
// Count messages in a session
const messageCount = await memory.count("session123");

// Delete specific messages
await memory.delete(["message_id_1", "message_id_2"]);

// Clear entire session history
await memory.clear("session123");

// Get summary statistics
const stats = await memory.getStats();
console.log(`Total sessions: ${stats.sessionCount}`);
console.log(`Total messages: ${stats.messageCount}`);
```

## Working with Multiple Sessions

Memory can manage multiple separate conversations:

```typescript
// Add messages to different sessions
await memory.add({
  role: "user",
  content: "Tell me about France",
  sessionId: "travel_planning"
});

await memory.add({
  role: "user",
  content: "What's the capital of Germany?",
  sessionId: "geography_quiz"
});

// Retrieve individual session histories
const travelSession = await memory.getBySession("travel_planning");
const quizSession = await memory.getBySession("geography_quiz");
``` 

## Custom Table Names

You can customize the table name used for memory storage:

```typescript
// Use a custom table name for memory
const memory = await createMemory({
  database: db,
  tableName: "my_custom_memories",  // Custom table name
  maxEntries: 100
});

// This is useful for:
// - Avoiding conflicts in shared databases
// - Organizing data with prefixes (e.g., "app_memories")
// - Multi-tenancy scenarios
// - Legacy system integration
```

## Integration with Chat Management

Memory works seamlessly with the chat management system:

```typescript
import { createMemory, createChat, createDatabase } from '@astreus-ai/astreus';

const db = await createDatabase();

// Create memory instance
const memory = await createMemory({
  database: db,
  tableName: "conversations",
  maxEntries: 1000
});

// Create chat management (uses the same memory)
const chat = await createChat({
  database: db,
  memory: memory,  // Share the same memory instance
  tableName: "chat_metadata"
});

// Chat IDs are compatible with session IDs
const newChat = await chat.createChat({
  agentId: 'my-agent',
  userId: 'user123'
});

// Add message via chat system
await chat.addMessage({
  chatId: newChat.id,
  agentId: 'my-agent',
  userId: 'user123',
  role: 'user',
  content: 'Hello!'
});

// Retrieve via memory system (same data)
const messages = await memory.getBySession(newChat.id);
```

## Best Practices

### 1. Choose Appropriate Table Names
```typescript
// Good: Descriptive and organized
tableName: "customer_support_memories"
tableName: "app_conversations"

// Avoid: Generic names in shared environments
tableName: "memories"
```

### 2. Set Reasonable Limits
```typescript
// For chat applications
maxEntries: 100  // Keep recent context

// For long-term knowledge retention
maxEntries: 1000  // Store more history
```

### 3. Use Embeddings for Search
```typescript
// Enable embeddings for applications that need search
const memory = await createMemory({
  database: db,
  tableName: "searchable_conversations",
  enableEmbeddings: true,
  maxEntries: 500
});
```

### 4. Organize with Metadata
```typescript
await memory.add({
  role: "user",
  content: "Question about exports",
  sessionId: "session123",
  metadata: {
    category: "business",
    priority: "high",
    department: "exports"
  }
});
``` 